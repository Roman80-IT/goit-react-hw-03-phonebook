# Книга контактів

Візьми своє рішення завдання з попередньої домашньої роботи і додай зберігання
контактів телефонної книги в `localStorage`. Використовуй методи життєвого
циклу.

- Під час додавання та видалення контакту контакти зберігаються у локальне
  сховище.
- Під час завантаження застосунку контакти, якщо такі є, зчитуються з локального
  сховища і записуються у стан.

## Підготовка

`package.json`

```jsx
"homepage": "https://Roman80-IT.github.io/goit-react-hw-03-phonebook/",
```

### Усунення помилок при інсталяції

---

помилки пов'язані з застарілими версіями пакетів, які використовуються в
проекті. Щоб їх виправити, потрібно оновити ці пакети до актуальних версій.
Можна зробити це за допомогою `npm` (`Node Package Manager`) команди
`npm install` або `npm update`.

```
npm install @babel/plugin-transform-class-properties --save-dev

npm install @babel/plugin-transform-private-property-in-object --save-dev

npm install @babel/plugin-transform-object-rest-spread --save-dev

npm install svgo@2 --save-dev
```

---

Застосунок повинен складатися з форми і списку контактів. На поточному кроці
реалізуй додавання імені контакту та відображення списку контактів. Застосунок
не повинен зберігати контакти між різними сесіями (оновлення сторінки).

Використовуйте цю розмітку інпуту для імені контакту.

```html
<input type="text" name="name" required />
```

Стан, що зберігається в батьківському компоненті **`<App>`**, обов'язково
повинен бути наступного вигляду, додавати нові властивості не можна.

```jsx
state = {
  contacts: [],
  name: '',
};
```

Кожен контакт повинен бути об'єктом з властивостями `name` та `id`. Для
генерації ідентифікаторів використовуй будь-який відповідний пакет, наприклад
**nanoid**. Після завершення цього кроку, застосунок повинен виглядати приблизно
так.

## Крок 2

Розшир функціонал застосунку, дозволивши користувачам додавати номери телефонів.
Для цього додай <input type="tel"> у форму і властивість для зберігання його
значення в стані.

```jsx
state = {
  contacts: [],
  name: '',
  number: '',
};
```

Використовуй цю розмітку інпуту для номеру контакту.

```html
<input type="tel" name="number" required />
```

Після завершення цього кроку, застосунок повинен виглядати приблизно так.

## Крок 3

Додай поле пошуку, яке можна використовувати для фільтрації списку контактів за
ім'ям.

Поле пошуку – це інпут без форми, значення якого записується у стан
(контрольований елемент). Логіка фільтрації повинна бути нечутливою до регістру.

```jsx
state = {
  contacts: [],
  filter: '',
  name: '',
  number: '',
};
```

Коли ми працюємо над новим функціоналом, буває зручно жорстко закодувати деякі
дані у стан. Це позбавить необхідності вручну вводити дані в інтерфейсі для
тестування роботи нового функціоналу. Наприклад, можна використовувати такий
початковий стан.

```jsx
state = {
  contacts: [
    { id: 'id-1', name: 'Rosie Simpson', number: '459-12-56' },
    { id: 'id-2', name: 'Hermione Kline', number: '443-89-12' },
    { id: 'id-3', name: 'Eden Clements', number: '645-17-79' },
    { id: 'id-4', name: 'Annie Copeland', number: '227-91-26' },
  ],
  filter: '',
  name: '',
  number: '',
};
```

## Крок 4

Якщо твій застосунок реалізований в одному компоненті `<App>`, виконай
рефакторинг, виділивши відповідні частини в окремі компоненти. У стані
кореневого компонента <App> залишаться тільки властивості contacts і filter.

```jsx
state = {
  contacts: [],
  filter: '',
};
```

Достатньо виділити чотири компоненти: форма додавання контактів, список
контактів, елемент списку контактів та фільтр пошуку.

Після рефакторингу кореневий компонент застосунку виглядатиме так.

```html
<div>
  <h1>Phonebook</h1>
  <ContactForm ... />

  <h2>Contacts</h2>
  <Filter ... />
  <ContactList ... />
</div>
```

## Крок 5

Заборони користувачеві можливість додавати контакти, імена яких вже присутні у
телефонній книзі. При спробі виконати таку дію виведи alert із попередженням.

## Крок 6

Розшир функціонал застосунку, дозволивши користувачеві видаляти раніше збережені
контакти.

# Настанови ментора

Основний стейт повинен бути в **`Арр`**:

```jsx
state = {
  contacts: [],
  filter: '',
};
```

Для перевірки існуючого контакту використовуйте `патерн "раннє повернення"`:

```jsx
if (isExist) {
  alert(`${name} is already in contacts.`);
  return;
}
```

В компонент **ContactsList** передаємо два props:

- список відфільтрованих контактів;
- посилання на функцію для видалення контакту.

Можете використати ці патерни, замість тих, що запропоновані в ТЗ до ДЗ щоб в
консолі не було помилок:

```jsx
pattern = "^[a-zA-Zа-яА-Я]+(([' \\-][a-zA-Zа-яА-Я ])?[a-zA-Zа-яА-Я]*)*$";
pattern =
  '\\+?\\d{1,4}?[ .\\-\\s]?\\(?\\d{1,3}?\\)?[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,9}';
```

# Виконання

Для генерації унікальних ідентифікаторів за допомогою пакету `nanoid` спершу
потрібно встановити пакет `nanoid` у проекті:

```jsx
npm install nanoid
```

Приклад, як можна згенерувати ідентифікатори для об'єктів:

```jsx
import { nanoid } from 'nanoid';
// const { nanoid } = require('nanoid'); - стара версія імпорту

const id1 = nanoid();
const id2 = nanoid();
const id3 = nanoid();
const id4 = nanoid();

console.log(id1, id2, id3, id4);
```

У цьому прикладі використовуємо `nanoid()` для генерації унікальних
ідентифікаторів `(id1, id2, id3, id4)`.

## Крок 1

- Створюємо компоненти **`ContactList`**, який відображає список контактів
- та батьківський компонент **`App`** для керування станом додатку і додавання
  нових контактів. Контакти зберігаються в стейт (в стані) **`App`** у вигляді
  масиву об'єктів з властивостями `name` і `id`.

- Для генерації ідентифікаторів контактів використовуємо бібліотеку `nanoid`.

## Крок 3

Для додавання поля пошуку та фільтрації контактів за іменем, спочатку додамо
інпут для пошуку, який буде управлятися станом компонента App. Поле пошуку буде
фільтрувати контакти на основі введеного тексту.

Додали компонент **Filter**, що приймає `filter` та `onFilterChange` як пропси.

- `filter` - це значення текстового поля для фільтрації,
- `onFilterChange` - це ф-ція, яка відбувається при зміні текстового поля. В
  **App** ми передаємо значення фільтрації (`filter`) та функцію зміни
  фільтрації (`handleFilterChange`) до компонента **Filter**.

У компоненті **ContactList**, використовуємо `filter` для відображення
відфільтрованих контактів на основі імені. Фільтрування є нечутливим до
регістру.

### як функціонує фільтрація:

1. **Додавання поля пошуку**: створено новий компонент **Filter**, який приймає
   значення фільтра та функцію зміни фільтрації через пропси. У компоненті
   **`App`**, ми включили цей компонент, щоб додати поле пошуку в інтерфейс.

2. **Фільтрація за іменем**: Для фільтрації контактів за іменем використовуємо
   стан `filter` в компоненті **`App`**. Поле введення пошуку контролює цей стан
   і передає його значення до компонента **`Filter`**. У компоненті
   **`ContactList`**, фільтруємо список контактів на основі значення `filter`,
   використовуючи метод `.filter()`.

Ф-ція `handleFilterChange` оновлює стан `filter` на основі змін в полі введення.
Т. ч., при зміні значення поля введення пошуку, фільтруємо список контактів на
основі нового значення і відображаємо відфільтровані результати.

### Логіка фільтрації:

- Додаються контакти за допомогою імен та номерів телефонів за допомогою
  відповідних полів введення.
- Використовується поле введення ' "Find contacts" ' для пошуку контактів за
  іменем.
- Ввод ім'я в поле дозволяє побачите результати фільтрації на основі введеного
  тексту.
- Фільтрація є нечутливою до регістру, тому можна вводити текст пошуку як з
  великої, так і з малої літери.

Ця логіка дозволяє легко фільтрувати та відображати контакти за іменем у
застосунку для телефонної книги.

## Крок 5

в компоненті **`App`** контролюється заборона додавати контакти з іменами, які
вже присутні в телефонній книзі.

Важливо передати список контактів у компонент **`ContactForm`** через пропс
`contacts`. У ф-ції `handleAddContact` в компоненті **`App`**, тепер перевіряємо
наявність імені в списку контактів перед додаванням нового контакту. Якщо ім'я
вже існує, то виводиться попередження і додавання контакту не відбувається.

Для перевірки існуючого контакту використано `contacts.**some**()` та
`патерн "раннього повернення"`:

```jsx
if (isExist) {
  alert(`${name} is already in contacts.`);
  return;
}
```

Таким чином, код нижче у ф-ції не виконується, якщо контакт вже існує, і
виводиться попередження.

## Крок 6

- Додано можливість видалення контакту зі списку контактів **`ContactList`** і
  відображено кнопку `"Delete"` для видалення кожного контакту.

- кнопка/и `"Delete"` викликає ф-цію `onDeleteContact` при кліку і передає
  ідентифікатор контакту.

- Далі, в компоненті **`App`** створено ф-цію для видалення контакту за
  ідентифікатором і передано її у компонент **`ContactList`**

- Тепер є можливість видаляти контакти, натискаючи кнопку `"Delete"` поруч із
  кожним контактом. Ф-ція `handleDeleteContact` видаляє контакт за його
  ідентифікатором, і оновлений список контактів відображається на сторінці після
  видалення.

## Патерни

Додамо патерни як атрибути pattern у відповідних полях вводу (<input>)

```jsx
pattern = "^[a-zA-Zа-яА-Я]+(([' \\-][a-zA-Zа-яА-Я ])?[a-zA-Zа-яА-Я]*)*$";
```

може бути використаний для валідації імен контактів. Він дозволяє вводити імена,
які містять літери латинського або кириличного алфавіту, а також може включати
пробіли, апострофи і тире між словами у імені.

```jsx
pattern =
  '\\+?\\d{1,4}?[ .\\-\\s]?\\(?\\d{1,3}?\\)?[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,9}';
```

для валідації номерів телефонів. Він дозволяє вводити різні формати номерів,
включаючи можливість вказати код країни з "+" в початку, роздільники (крапки,
тире, пробіли), а також може включати кілька блоків цифр у номері.

Використання цих патернів у полях введення дозволитьзабезпечити коректну
валідацію імен контактів і номерів телефонів, і сприятиме введенню даних
користувачем в відповідному форматі.

## Бібліотеки `yup` та `formik`

```
npm install yup formik
```

Після використовування **`Formik`** та **`Yup`** для валідації у компоненті
**ContactForm**, більше не потрібно визначати стан компонента через `state`.
Замість цього - визначаються початкові значення полів у компоненті **Formik**
через властивість `initialValues` (визначає початкові значення для полів `name`
та `number`)

## ContactList

Початкова розмітка:

```jsx
  render() {
    const { contacts } = this.props;

    return (
      <div>
        <ul>
          {contacts.map(contact => (
            <li key={contact.id}>
              {contact.name}: {contact.number}
            </li>
          ))}
        </ul>
      </div>
    );
  }
```

## Стилізація

- імпорт іконки `MdOutlineRemoveCircleOutline` з пакету `react-icons/md`

```jsx
npm install react-icons

import { MdOutlineRemoveCircleOutline } from 'react-icons/md';
```

Встановлення `styled components`:

```
npm install styled-components
```

- фікс помилки установки пакета:

```
npm install --save-dev @babel/plugin-proposal-private-property-in-object
```

## Fix error

Для правильної роботи компонентів **`App`** і **`ContactForm`**, необхідно
враховувати:

Компонент **`App`** має визначити ф-цію для додавання контакту (напр.
`handleAddContact`) і передати її як пропс компоненту **`ContactForm`**.

Компонент **`ContactForm`** має приймати цю ф-цію як один з своїх пропсів і
використовувати її для додавання нових контактів.

Важливо, щоб назви пропсів у компонентах співпадали з тими, які визначили в
**`App`**. Наприклад, якщо у **`App`** ви визначили функцію для додавання
контакту як `handleAddContact`, то в компоненті **`ContactForm`** ви можете
передати цю функцію через пропс з аналогічною назвою, наприклад, `onAddContact`:

```jsx
// В компоненті App

<ContactForm onAddContact={this.handleAddContact} />
```

```jsx
// В компоненті ContactForm

const { onAddContact } = this.props;
```

Це дозволить викликати функцію `onAddContact` у компоненті **`ContactForm`**,
щоб додати нові контакти. **Пам'ятай**, що назви пропсів мають співпадати - вони
можуть мати різні імена у компонентах, але вони повинні бути правильно вказані
при передачі.

У компоненті **`App`**:

```jsx
<ContactForm onAddContact={this.handleAddContact} />
```

У компоненті **`ContactForm`**:

```jsx
const { onAddContact } = this.props;
```

Це дозволить **`ContactForm`** коректно викликати ф-цію `handleAddContact` у
**`App`**.

## Mentor's remarks

Не ок рішення ось так анонімкою передавати значення у проп

```jsx
contacts={contacts.filter(contact =>
contact.name.toLowerCase().includes(filter.toLowerCase()) )}
```

Винесіть його в окремий метод
